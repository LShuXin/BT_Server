// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: IM.BaseDefine.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "ImBaseDefine.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - ImBaseDefineRoot

@implementation ImBaseDefineRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - ImBaseDefineRoot_FileDescriptor

static GPBFileDescriptor *ImBaseDefineRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"IM.BaseDefine"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum ServiceID

GPBEnumDescriptor *ServiceID_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "SidNone\000SidLogin\000SidBuddyList\000SidMsg\000Sid"
        "Group\000SidFile\000SidSwitchService\000SidOther\000"
        "SidInternal\000";
    static const int32_t values[] = {
        ServiceID_SidNone,
        ServiceID_SidLogin,
        ServiceID_SidBuddyList,
        ServiceID_SidMsg,
        ServiceID_SidGroup,
        ServiceID_SidFile,
        ServiceID_SidSwitchService,
        ServiceID_SidOther,
        ServiceID_SidInternal,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ServiceID)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ServiceID_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ServiceID_IsValidValue(int32_t value__) {
  switch (value__) {
    case ServiceID_SidNone:
    case ServiceID_SidLogin:
    case ServiceID_SidBuddyList:
    case ServiceID_SidMsg:
    case ServiceID_SidGroup:
    case ServiceID_SidFile:
    case ServiceID_SidSwitchService:
    case ServiceID_SidOther:
    case ServiceID_SidInternal:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum InternalCmdID

GPBEnumDescriptor *InternalCmdID_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "CidInternalNone\000CidInternalSyncAuthInfoR"
        "eq\000CidInternalSyncAuthInfoRsp\000CidInterna"
        "lUserIdByNickNameReq\000CidInternalUserIdBy"
        "NickNameRsp\000";
    static const int32_t values[] = {
        InternalCmdID_CidInternalNone,
        InternalCmdID_CidInternalSyncAuthInfoReq,
        InternalCmdID_CidInternalSyncAuthInfoRsp,
        InternalCmdID_CidInternalUserIdByNickNameReq,
        InternalCmdID_CidInternalUserIdByNickNameRsp,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(InternalCmdID)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:InternalCmdID_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL InternalCmdID_IsValidValue(int32_t value__) {
  switch (value__) {
    case InternalCmdID_CidInternalNone:
    case InternalCmdID_CidInternalSyncAuthInfoReq:
    case InternalCmdID_CidInternalSyncAuthInfoRsp:
    case InternalCmdID_CidInternalUserIdByNickNameReq:
    case InternalCmdID_CidInternalUserIdByNickNameRsp:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum LoginCmdID

GPBEnumDescriptor *LoginCmdID_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "CidLoginNone\000CidLoginReqMsgserver\000CidLog"
        "inResMsgserver\000CidLoginReqUserlogin\000CidL"
        "oginResUserlogin\000CidLoginReqLoginout\000Cid"
        "LoginResLoginout\000CidLoginKickUser\000CidLog"
        "inReqDevicetoken\000CidLoginResDevicetoken\000"
        "CidLoginReqKickpcclient\000CidLoginResKickp"
        "cclient\000CidLoginReqPushShield\000CidLoginRe"
        "sPushShield\000CidLoginReqQueryPushShield\000C"
        "idLoginResQueryPushShield\000";
    static const int32_t values[] = {
        LoginCmdID_CidLoginNone,
        LoginCmdID_CidLoginReqMsgserver,
        LoginCmdID_CidLoginResMsgserver,
        LoginCmdID_CidLoginReqUserlogin,
        LoginCmdID_CidLoginResUserlogin,
        LoginCmdID_CidLoginReqLoginout,
        LoginCmdID_CidLoginResLoginout,
        LoginCmdID_CidLoginKickUser,
        LoginCmdID_CidLoginReqDevicetoken,
        LoginCmdID_CidLoginResDevicetoken,
        LoginCmdID_CidLoginReqKickpcclient,
        LoginCmdID_CidLoginResKickpcclient,
        LoginCmdID_CidLoginReqPushShield,
        LoginCmdID_CidLoginResPushShield,
        LoginCmdID_CidLoginReqQueryPushShield,
        LoginCmdID_CidLoginResQueryPushShield,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(LoginCmdID)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:LoginCmdID_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL LoginCmdID_IsValidValue(int32_t value__) {
  switch (value__) {
    case LoginCmdID_CidLoginNone:
    case LoginCmdID_CidLoginReqMsgserver:
    case LoginCmdID_CidLoginResMsgserver:
    case LoginCmdID_CidLoginReqUserlogin:
    case LoginCmdID_CidLoginResUserlogin:
    case LoginCmdID_CidLoginReqLoginout:
    case LoginCmdID_CidLoginResLoginout:
    case LoginCmdID_CidLoginKickUser:
    case LoginCmdID_CidLoginReqDevicetoken:
    case LoginCmdID_CidLoginResDevicetoken:
    case LoginCmdID_CidLoginReqKickpcclient:
    case LoginCmdID_CidLoginResKickpcclient:
    case LoginCmdID_CidLoginReqPushShield:
    case LoginCmdID_CidLoginResPushShield:
    case LoginCmdID_CidLoginReqQueryPushShield:
    case LoginCmdID_CidLoginResQueryPushShield:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum BuddyListCmdID

GPBEnumDescriptor *BuddyListCmdID_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "CidBuddyListNone\000CidBuddyListRecentConta"
        "ctSessionRequest\000CidBuddyListRecentConta"
        "ctSessionResponse\000CidBuddyListStatusNoti"
        "fy\000CidBuddyListUserInfoRequest\000CidBuddyL"
        "istUserInfoResponse\000CidBuddyListRemoveSe"
        "ssionReq\000CidBuddyListRemoveSessionRes\000Ci"
        "dBuddyListAllUserRequest\000CidBuddyListAll"
        "UserResponse\000CidBuddyListUsersStatusRequ"
        "est\000CidBuddyListUsersStatusResponse\000CidB"
        "uddyListChangeAvatarRequest\000CidBuddyList"
        "ChangeAvatarResponse\000CidBuddyListPcLogin"
        "StatusNotify\000CidBuddyListRemoveSessionNo"
        "tify\000CidBuddyListDepartmentRequest\000CidBu"
        "ddyListDepartmentResponse\000CidBuddyListAv"
        "atarChangedNotify\000CidBuddyListChangeSign"
        "InfoRequest\000CidBuddyListChangeSignInfoRe"
        "sponse\000CidBuddyListSignInfoChangedNotify"
        "\000";
    static const int32_t values[] = {
        BuddyListCmdID_CidBuddyListNone,
        BuddyListCmdID_CidBuddyListRecentContactSessionRequest,
        BuddyListCmdID_CidBuddyListRecentContactSessionResponse,
        BuddyListCmdID_CidBuddyListStatusNotify,
        BuddyListCmdID_CidBuddyListUserInfoRequest,
        BuddyListCmdID_CidBuddyListUserInfoResponse,
        BuddyListCmdID_CidBuddyListRemoveSessionReq,
        BuddyListCmdID_CidBuddyListRemoveSessionRes,
        BuddyListCmdID_CidBuddyListAllUserRequest,
        BuddyListCmdID_CidBuddyListAllUserResponse,
        BuddyListCmdID_CidBuddyListUsersStatusRequest,
        BuddyListCmdID_CidBuddyListUsersStatusResponse,
        BuddyListCmdID_CidBuddyListChangeAvatarRequest,
        BuddyListCmdID_CidBuddyListChangeAvatarResponse,
        BuddyListCmdID_CidBuddyListPcLoginStatusNotify,
        BuddyListCmdID_CidBuddyListRemoveSessionNotify,
        BuddyListCmdID_CidBuddyListDepartmentRequest,
        BuddyListCmdID_CidBuddyListDepartmentResponse,
        BuddyListCmdID_CidBuddyListAvatarChangedNotify,
        BuddyListCmdID_CidBuddyListChangeSignInfoRequest,
        BuddyListCmdID_CidBuddyListChangeSignInfoResponse,
        BuddyListCmdID_CidBuddyListSignInfoChangedNotify,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(BuddyListCmdID)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:BuddyListCmdID_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL BuddyListCmdID_IsValidValue(int32_t value__) {
  switch (value__) {
    case BuddyListCmdID_CidBuddyListNone:
    case BuddyListCmdID_CidBuddyListRecentContactSessionRequest:
    case BuddyListCmdID_CidBuddyListRecentContactSessionResponse:
    case BuddyListCmdID_CidBuddyListStatusNotify:
    case BuddyListCmdID_CidBuddyListUserInfoRequest:
    case BuddyListCmdID_CidBuddyListUserInfoResponse:
    case BuddyListCmdID_CidBuddyListRemoveSessionReq:
    case BuddyListCmdID_CidBuddyListRemoveSessionRes:
    case BuddyListCmdID_CidBuddyListAllUserRequest:
    case BuddyListCmdID_CidBuddyListAllUserResponse:
    case BuddyListCmdID_CidBuddyListUsersStatusRequest:
    case BuddyListCmdID_CidBuddyListUsersStatusResponse:
    case BuddyListCmdID_CidBuddyListChangeAvatarRequest:
    case BuddyListCmdID_CidBuddyListChangeAvatarResponse:
    case BuddyListCmdID_CidBuddyListPcLoginStatusNotify:
    case BuddyListCmdID_CidBuddyListRemoveSessionNotify:
    case BuddyListCmdID_CidBuddyListDepartmentRequest:
    case BuddyListCmdID_CidBuddyListDepartmentResponse:
    case BuddyListCmdID_CidBuddyListAvatarChangedNotify:
    case BuddyListCmdID_CidBuddyListChangeSignInfoRequest:
    case BuddyListCmdID_CidBuddyListChangeSignInfoResponse:
    case BuddyListCmdID_CidBuddyListSignInfoChangedNotify:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum MessageCmdID

GPBEnumDescriptor *MessageCmdID_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "CidMsgNone\000CidMsgData\000CidMsgDataAck\000CidM"
        "sgReadAck\000CidMsgReadNotify\000CidMsgTimeReq"
        "uest\000CidMsgTimeResponse\000CidMsgUnreadCntR"
        "equest\000CidMsgUnreadCntResponse\000CidMsgLis"
        "tRequest\000CidMsgListResponse\000CidMsgGetLat"
        "estMsgIdReq\000CidMsgGetLatestMsgIdRsp\000CidM"
        "sgGetByMsgIdReq\000CidMsgGetByMsgIdRes\000";
    static const int32_t values[] = {
        MessageCmdID_CidMsgNone,
        MessageCmdID_CidMsgData,
        MessageCmdID_CidMsgDataAck,
        MessageCmdID_CidMsgReadAck,
        MessageCmdID_CidMsgReadNotify,
        MessageCmdID_CidMsgTimeRequest,
        MessageCmdID_CidMsgTimeResponse,
        MessageCmdID_CidMsgUnreadCntRequest,
        MessageCmdID_CidMsgUnreadCntResponse,
        MessageCmdID_CidMsgListRequest,
        MessageCmdID_CidMsgListResponse,
        MessageCmdID_CidMsgGetLatestMsgIdReq,
        MessageCmdID_CidMsgGetLatestMsgIdRsp,
        MessageCmdID_CidMsgGetByMsgIdReq,
        MessageCmdID_CidMsgGetByMsgIdRes,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(MessageCmdID)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:MessageCmdID_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL MessageCmdID_IsValidValue(int32_t value__) {
  switch (value__) {
    case MessageCmdID_CidMsgNone:
    case MessageCmdID_CidMsgData:
    case MessageCmdID_CidMsgDataAck:
    case MessageCmdID_CidMsgReadAck:
    case MessageCmdID_CidMsgReadNotify:
    case MessageCmdID_CidMsgTimeRequest:
    case MessageCmdID_CidMsgTimeResponse:
    case MessageCmdID_CidMsgUnreadCntRequest:
    case MessageCmdID_CidMsgUnreadCntResponse:
    case MessageCmdID_CidMsgListRequest:
    case MessageCmdID_CidMsgListResponse:
    case MessageCmdID_CidMsgGetLatestMsgIdReq:
    case MessageCmdID_CidMsgGetLatestMsgIdRsp:
    case MessageCmdID_CidMsgGetByMsgIdReq:
    case MessageCmdID_CidMsgGetByMsgIdRes:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum GroupCmdID

GPBEnumDescriptor *GroupCmdID_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "CidGroupNone\000CidGroupNormalListRequest\000C"
        "idGroupNormalListResponse\000CidGroupInfoRe"
        "quest\000CidGroupInfoResponse\000CidGroupCreat"
        "eRequest\000CidGroupCreateResponse\000CidGroup"
        "ChangeMemberRequest\000CidGroupChangeMember"
        "Response\000CidGroupShieldGroupRequest\000CidG"
        "roupShieldGroupResponse\000CidGroupChangeMe"
        "mberNotify\000";
    static const int32_t values[] = {
        GroupCmdID_CidGroupNone,
        GroupCmdID_CidGroupNormalListRequest,
        GroupCmdID_CidGroupNormalListResponse,
        GroupCmdID_CidGroupInfoRequest,
        GroupCmdID_CidGroupInfoResponse,
        GroupCmdID_CidGroupCreateRequest,
        GroupCmdID_CidGroupCreateResponse,
        GroupCmdID_CidGroupChangeMemberRequest,
        GroupCmdID_CidGroupChangeMemberResponse,
        GroupCmdID_CidGroupShieldGroupRequest,
        GroupCmdID_CidGroupShieldGroupResponse,
        GroupCmdID_CidGroupChangeMemberNotify,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(GroupCmdID)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:GroupCmdID_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL GroupCmdID_IsValidValue(int32_t value__) {
  switch (value__) {
    case GroupCmdID_CidGroupNone:
    case GroupCmdID_CidGroupNormalListRequest:
    case GroupCmdID_CidGroupNormalListResponse:
    case GroupCmdID_CidGroupInfoRequest:
    case GroupCmdID_CidGroupInfoResponse:
    case GroupCmdID_CidGroupCreateRequest:
    case GroupCmdID_CidGroupCreateResponse:
    case GroupCmdID_CidGroupChangeMemberRequest:
    case GroupCmdID_CidGroupChangeMemberResponse:
    case GroupCmdID_CidGroupShieldGroupRequest:
    case GroupCmdID_CidGroupShieldGroupResponse:
    case GroupCmdID_CidGroupChangeMemberNotify:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum FileCmdID

GPBEnumDescriptor *FileCmdID_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "CidFileNone\000CidFileLoginReq\000CidFileLogin"
        "Res\000CidFileState\000CidFilePullDataReq\000CidF"
        "ilePullDataRsp\000CidFileRequest\000CidFileRes"
        "ponse\000CidFileNotify\000CidFileHasOfflineReq"
        "\000CidFileHasOfflineRes\000CidFileAddOfflineR"
        "eq\000CidFileDelOfflineReq\000";
    static const int32_t values[] = {
        FileCmdID_CidFileNone,
        FileCmdID_CidFileLoginReq,
        FileCmdID_CidFileLoginRes,
        FileCmdID_CidFileState,
        FileCmdID_CidFilePullDataReq,
        FileCmdID_CidFilePullDataRsp,
        FileCmdID_CidFileRequest,
        FileCmdID_CidFileResponse,
        FileCmdID_CidFileNotify,
        FileCmdID_CidFileHasOfflineReq,
        FileCmdID_CidFileHasOfflineRes,
        FileCmdID_CidFileAddOfflineReq,
        FileCmdID_CidFileDelOfflineReq,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(FileCmdID)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:FileCmdID_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL FileCmdID_IsValidValue(int32_t value__) {
  switch (value__) {
    case FileCmdID_CidFileNone:
    case FileCmdID_CidFileLoginReq:
    case FileCmdID_CidFileLoginRes:
    case FileCmdID_CidFileState:
    case FileCmdID_CidFilePullDataReq:
    case FileCmdID_CidFilePullDataRsp:
    case FileCmdID_CidFileRequest:
    case FileCmdID_CidFileResponse:
    case FileCmdID_CidFileNotify:
    case FileCmdID_CidFileHasOfflineReq:
    case FileCmdID_CidFileHasOfflineRes:
    case FileCmdID_CidFileAddOfflineReq:
    case FileCmdID_CidFileDelOfflineReq:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum SwitchServiceCmdID

GPBEnumDescriptor *SwitchServiceCmdID_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "CidSwitchNone\000CidSwitchP2PCmd\000";
    static const int32_t values[] = {
        SwitchServiceCmdID_CidSwitchNone,
        SwitchServiceCmdID_CidSwitchP2PCmd,
    };
    static const char *extraTextFormatInfo = "\001\001c\346\203\343\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SwitchServiceCmdID)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SwitchServiceCmdID_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SwitchServiceCmdID_IsValidValue(int32_t value__) {
  switch (value__) {
    case SwitchServiceCmdID_CidSwitchNone:
    case SwitchServiceCmdID_CidSwitchP2PCmd:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum OtherCmdID

GPBEnumDescriptor *OtherCmdID_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "CidOtherNone\000CidOtherHeartbeat\000CidOtherS"
        "topRecvPacket\000CidOtherValidateReq\000CidOth"
        "erValidateRsp\000CidOtherGetDeviceTokenReq\000"
        "CidOtherGetDeviceTokenRsp\000CidOtherRoleSe"
        "t\000CidOtherOnlineUserInfo\000CidOtherMsgServ"
        "Info\000CidOtherUserStatusUpdate\000CidOtherUs"
        "erCntUpdate\000CidOtherServerKickUser\000CidOt"
        "herLoginStatusNotify\000CidOtherPushToUserR"
        "eq\000CidOtherPushToUserRsp\000CidOtherGetShie"
        "ldReq\000CidOtherGetShieldRsp\000CidOtherFileT"
        "ransferReq\000CidOtherFileTransferRsp\000CidOt"
        "herFileServerIpReq\000CidOtherFileServerIpR"
        "sp\000";
    static const int32_t values[] = {
        OtherCmdID_CidOtherNone,
        OtherCmdID_CidOtherHeartbeat,
        OtherCmdID_CidOtherStopRecvPacket,
        OtherCmdID_CidOtherValidateReq,
        OtherCmdID_CidOtherValidateRsp,
        OtherCmdID_CidOtherGetDeviceTokenReq,
        OtherCmdID_CidOtherGetDeviceTokenRsp,
        OtherCmdID_CidOtherRoleSet,
        OtherCmdID_CidOtherOnlineUserInfo,
        OtherCmdID_CidOtherMsgServInfo,
        OtherCmdID_CidOtherUserStatusUpdate,
        OtherCmdID_CidOtherUserCntUpdate,
        OtherCmdID_CidOtherServerKickUser,
        OtherCmdID_CidOtherLoginStatusNotify,
        OtherCmdID_CidOtherPushToUserReq,
        OtherCmdID_CidOtherPushToUserRsp,
        OtherCmdID_CidOtherGetShieldReq,
        OtherCmdID_CidOtherGetShieldRsp,
        OtherCmdID_CidOtherFileTransferReq,
        OtherCmdID_CidOtherFileTransferRsp,
        OtherCmdID_CidOtherFileServerIpReq,
        OtherCmdID_CidOtherFileServerIpRsp,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(OtherCmdID)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:OtherCmdID_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL OtherCmdID_IsValidValue(int32_t value__) {
  switch (value__) {
    case OtherCmdID_CidOtherNone:
    case OtherCmdID_CidOtherHeartbeat:
    case OtherCmdID_CidOtherStopRecvPacket:
    case OtherCmdID_CidOtherValidateReq:
    case OtherCmdID_CidOtherValidateRsp:
    case OtherCmdID_CidOtherGetDeviceTokenReq:
    case OtherCmdID_CidOtherGetDeviceTokenRsp:
    case OtherCmdID_CidOtherRoleSet:
    case OtherCmdID_CidOtherOnlineUserInfo:
    case OtherCmdID_CidOtherMsgServInfo:
    case OtherCmdID_CidOtherUserStatusUpdate:
    case OtherCmdID_CidOtherUserCntUpdate:
    case OtherCmdID_CidOtherServerKickUser:
    case OtherCmdID_CidOtherLoginStatusNotify:
    case OtherCmdID_CidOtherPushToUserReq:
    case OtherCmdID_CidOtherPushToUserRsp:
    case OtherCmdID_CidOtherGetShieldReq:
    case OtherCmdID_CidOtherGetShieldRsp:
    case OtherCmdID_CidOtherFileTransferReq:
    case OtherCmdID_CidOtherFileTransferRsp:
    case OtherCmdID_CidOtherFileServerIpReq:
    case OtherCmdID_CidOtherFileServerIpRsp:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ResultType

GPBEnumDescriptor *ResultType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "RefuseReasonNone\000RefuseReasonNoMsgServer"
        "\000RefuseReasonMsgServerFull\000RefuseReasonN"
        "oDbServer\000RefuseReasonNoLoginServer\000Refu"
        "seReasonNoRouteServer\000RefuseReasonDbVali"
        "dateFailed\000RefuseReasonVersionTooOld\000";
    static const int32_t values[] = {
        ResultType_RefuseReasonNone,
        ResultType_RefuseReasonNoMsgServer,
        ResultType_RefuseReasonMsgServerFull,
        ResultType_RefuseReasonNoDbServer,
        ResultType_RefuseReasonNoLoginServer,
        ResultType_RefuseReasonNoRouteServer,
        ResultType_RefuseReasonDbValidateFailed,
        ResultType_RefuseReasonVersionTooOld,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ResultType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ResultType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ResultType_IsValidValue(int32_t value__) {
  switch (value__) {
    case ResultType_RefuseReasonNone:
    case ResultType_RefuseReasonNoMsgServer:
    case ResultType_RefuseReasonMsgServerFull:
    case ResultType_RefuseReasonNoDbServer:
    case ResultType_RefuseReasonNoLoginServer:
    case ResultType_RefuseReasonNoRouteServer:
    case ResultType_RefuseReasonDbValidateFailed:
    case ResultType_RefuseReasonVersionTooOld:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum KickReasonType

GPBEnumDescriptor *KickReasonType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "KickReasonNone\000KickReasonDuplicateUser\000K"
        "ickReasonMobileKick\000";
    static const int32_t values[] = {
        KickReasonType_KickReasonNone,
        KickReasonType_KickReasonDuplicateUser,
        KickReasonType_KickReasonMobileKick,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(KickReasonType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:KickReasonType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL KickReasonType_IsValidValue(int32_t value__) {
  switch (value__) {
    case KickReasonType_KickReasonNone:
    case KickReasonType_KickReasonDuplicateUser:
    case KickReasonType_KickReasonMobileKick:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum OnlineListType

GPBEnumDescriptor *OnlineListType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "OnlineListTypeNone\000OnlineListTypeFriendL"
        "ist\000";
    static const int32_t values[] = {
        OnlineListType_OnlineListTypeNone,
        OnlineListType_OnlineListTypeFriendList,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(OnlineListType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:OnlineListType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL OnlineListType_IsValidValue(int32_t value__) {
  switch (value__) {
    case OnlineListType_OnlineListTypeNone:
    case OnlineListType_OnlineListTypeFriendList:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum UserStatType

GPBEnumDescriptor *UserStatType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "UserStatusNone\000UserStatusOnline\000UserStat"
        "usOffline\000UserStatusLeave\000";
    static const int32_t values[] = {
        UserStatType_UserStatusNone,
        UserStatType_UserStatusOnline,
        UserStatType_UserStatusOffline,
        UserStatType_UserStatusLeave,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(UserStatType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:UserStatType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL UserStatType_IsValidValue(int32_t value__) {
  switch (value__) {
    case UserStatType_UserStatusNone:
    case UserStatType_UserStatusOnline:
    case UserStatType_UserStatusOffline:
    case UserStatType_UserStatusLeave:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum SessionType

GPBEnumDescriptor *SessionType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "SessionTypeNone\000SessionTypeSingle\000Sessio"
        "nTypeGroup\000";
    static const int32_t values[] = {
        SessionType_SessionTypeNone,
        SessionType_SessionTypeSingle,
        SessionType_SessionTypeGroup,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SessionType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SessionType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SessionType_IsValidValue(int32_t value__) {
  switch (value__) {
    case SessionType_SessionTypeNone:
    case SessionType_SessionTypeSingle:
    case SessionType_SessionTypeGroup:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum MsgType

GPBEnumDescriptor *MsgType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "MsgTypeNone\000MsgTypeSingleText\000MsgTypeSin"
        "gleAudio\000MsgTypeGroupText\000MsgTypeGroupAu"
        "dio\000";
    static const int32_t values[] = {
        MsgType_MsgTypeNone,
        MsgType_MsgTypeSingleText,
        MsgType_MsgTypeSingleAudio,
        MsgType_MsgTypeGroupText,
        MsgType_MsgTypeGroupAudio,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(MsgType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:MsgType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL MsgType_IsValidValue(int32_t value__) {
  switch (value__) {
    case MsgType_MsgTypeNone:
    case MsgType_MsgTypeSingleText:
    case MsgType_MsgTypeSingleAudio:
    case MsgType_MsgTypeGroupText:
    case MsgType_MsgTypeGroupAudio:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ClientType

GPBEnumDescriptor *ClientType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ClientTypeNone\000ClientTypeWindows\000ClientT"
        "ypeMac\000ClientTypeIos\000ClientTypeAndroid\000";
    static const int32_t values[] = {
        ClientType_ClientTypeNone,
        ClientType_ClientTypeWindows,
        ClientType_ClientTypeMac,
        ClientType_ClientTypeIos,
        ClientType_ClientTypeAndroid,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ClientType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ClientType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ClientType_IsValidValue(int32_t value__) {
  switch (value__) {
    case ClientType_ClientTypeNone:
    case ClientType_ClientTypeWindows:
    case ClientType_ClientTypeMac:
    case ClientType_ClientTypeIos:
    case ClientType_ClientTypeAndroid:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum GroupType

GPBEnumDescriptor *GroupType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "GroupTypeNone\000GroupTypeNormal\000GroupTypeT"
        "mp\000";
    static const int32_t values[] = {
        GroupType_GroupTypeNone,
        GroupType_GroupTypeNormal,
        GroupType_GroupTypeTmp,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(GroupType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:GroupType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL GroupType_IsValidValue(int32_t value__) {
  switch (value__) {
    case GroupType_GroupTypeNone:
    case GroupType_GroupTypeNormal:
    case GroupType_GroupTypeTmp:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum GroupModifyType

GPBEnumDescriptor *GroupModifyType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "GroupModifyNone\000GroupModifyTypeAdd\000Group"
        "ModifyTypeDel\000";
    static const int32_t values[] = {
        GroupModifyType_GroupModifyNone,
        GroupModifyType_GroupModifyTypeAdd,
        GroupModifyType_GroupModifyTypeDel,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(GroupModifyType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:GroupModifyType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL GroupModifyType_IsValidValue(int32_t value__) {
  switch (value__) {
    case GroupModifyType_GroupModifyNone:
    case GroupModifyType_GroupModifyTypeAdd:
    case GroupModifyType_GroupModifyTypeDel:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum XFileType

GPBEnumDescriptor *XFileType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "FileTypeNone\000FileTypeOnline\000FileTypeOffl"
        "ine\000";
    static const int32_t values[] = {
        XFileType_FileTypeNone,
        XFileType_FileTypeOnline,
        XFileType_FileTypeOffline,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(XFileType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:XFileType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL XFileType_IsValidValue(int32_t value__) {
  switch (value__) {
    case XFileType_FileTypeNone:
    case XFileType_FileTypeOnline:
    case XFileType_FileTypeOffline:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ClientFileState

GPBEnumDescriptor *ClientFileState_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ClientFilePeerReady\000ClientFileCancel\000Cli"
        "entFileRefuse\000ClientFileDone\000";
    static const int32_t values[] = {
        ClientFileState_ClientFilePeerReady,
        ClientFileState_ClientFileCancel,
        ClientFileState_ClientFileRefuse,
        ClientFileState_ClientFileDone,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ClientFileState)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ClientFileState_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ClientFileState_IsValidValue(int32_t value__) {
  switch (value__) {
    case ClientFileState_ClientFilePeerReady:
    case ClientFileState_ClientFileCancel:
    case ClientFileState_ClientFileRefuse:
    case ClientFileState_ClientFileDone:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ClientFileRole

GPBEnumDescriptor *ClientFileRole_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ClientRealtimeNone\000ClientRealtimeSender\000"
        "ClientRealtimeRecver\000ClientOfflineUpload"
        "\000ClientOfflineDownload\000";
    static const int32_t values[] = {
        ClientFileRole_ClientRealtimeNone,
        ClientFileRole_ClientRealtimeSender,
        ClientFileRole_ClientRealtimeRecver,
        ClientFileRole_ClientOfflineUpload,
        ClientFileRole_ClientOfflineDownload,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ClientFileRole)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ClientFileRole_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ClientFileRole_IsValidValue(int32_t value__) {
  switch (value__) {
    case ClientFileRole_ClientRealtimeNone:
    case ClientFileRole_ClientRealtimeSender:
    case ClientFileRole_ClientRealtimeRecver:
    case ClientFileRole_ClientOfflineUpload:
    case ClientFileRole_ClientOfflineDownload:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum FileServerError

GPBEnumDescriptor *FileServerError_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "FileServerErrnoOk\000FileServerErrnoCreateT"
        "askIdError\000FileServerErrnoCreateTaskErro"
        "r\000FileServerErrnoLoginInvalidToken\000FileS"
        "erverErrnoInvalidUserForTask\000FileServerE"
        "rrnoPullDataWithInvalidTaskId\000FileServer"
        "ErrnoPullDataIllieageUser\000FileServerErrn"
        "oPullDataMkdirError\000FileServerErrnoPullD"
        "ataOpenFileError\000FileServerErrnoPullData"
        "ReadFileHeaderError\000FileServerErrnoPullD"
        "ataAllocMemError\000FileServerErrnoPullData"
        "SeekOffsetError\000FileServerErrnoPullDataF"
        "inished\000";
    static const int32_t values[] = {
        FileServerError_FileServerErrnoOk,
        FileServerError_FileServerErrnoCreateTaskIdError,
        FileServerError_FileServerErrnoCreateTaskError,
        FileServerError_FileServerErrnoLoginInvalidToken,
        FileServerError_FileServerErrnoInvalidUserForTask,
        FileServerError_FileServerErrnoPullDataWithInvalidTaskId,
        FileServerError_FileServerErrnoPullDataIllieageUser,
        FileServerError_FileServerErrnoPullDataMkdirError,
        FileServerError_FileServerErrnoPullDataOpenFileError,
        FileServerError_FileServerErrnoPullDataReadFileHeaderError,
        FileServerError_FileServerErrnoPullDataAllocMemError,
        FileServerError_FileServerErrnoPullDataSeekOffsetError,
        FileServerError_FileServerErrnoPullDataFinished,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(FileServerError)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:FileServerError_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL FileServerError_IsValidValue(int32_t value__) {
  switch (value__) {
    case FileServerError_FileServerErrnoOk:
    case FileServerError_FileServerErrnoCreateTaskIdError:
    case FileServerError_FileServerErrnoCreateTaskError:
    case FileServerError_FileServerErrnoLoginInvalidToken:
    case FileServerError_FileServerErrnoInvalidUserForTask:
    case FileServerError_FileServerErrnoPullDataWithInvalidTaskId:
    case FileServerError_FileServerErrnoPullDataIllieageUser:
    case FileServerError_FileServerErrnoPullDataMkdirError:
    case FileServerError_FileServerErrnoPullDataOpenFileError:
    case FileServerError_FileServerErrnoPullDataReadFileHeaderError:
    case FileServerError_FileServerErrnoPullDataAllocMemError:
    case FileServerError_FileServerErrnoPullDataSeekOffsetError:
    case FileServerError_FileServerErrnoPullDataFinished:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum SessionStatusType

GPBEnumDescriptor *SessionStatusType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "SessionStatusOk\000SessionStatusDelete\000";
    static const int32_t values[] = {
        SessionStatusType_SessionStatusOk,
        SessionStatusType_SessionStatusDelete,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SessionStatusType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SessionStatusType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SessionStatusType_IsValidValue(int32_t value__) {
  switch (value__) {
    case SessionStatusType_SessionStatusOk:
    case SessionStatusType_SessionStatusDelete:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum DepartmentStatusType

GPBEnumDescriptor *DepartmentStatusType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "DeptStatusOk\000DeptStatusDelete\000";
    static const int32_t values[] = {
        DepartmentStatusType_DeptStatusOk,
        DepartmentStatusType_DeptStatusDelete,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(DepartmentStatusType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:DepartmentStatusType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL DepartmentStatusType_IsValidValue(int32_t value__) {
  switch (value__) {
    case DepartmentStatusType_DeptStatusOk:
    case DepartmentStatusType_DeptStatusDelete:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - IpAddr

@implementation IpAddr

@dynamic ip;
@dynamic port;

typedef struct IpAddr__storage_ {
  uint32_t _has_storage_[1];
  uint32_t port;
  NSString *ip;
} IpAddr__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ip",
        .dataTypeSpecific.clazz = Nil,
        .number = IpAddr_FieldNumber_Ip,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IpAddr__storage_, ip),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "port",
        .dataTypeSpecific.clazz = Nil,
        .number = IpAddr_FieldNumber_Port,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IpAddr__storage_, port),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IpAddr class]
                                     rootClass:[ImBaseDefineRoot class]
                                          file:ImBaseDefineRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IpAddr__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserInfo

@implementation UserInfo

@dynamic userId;
@dynamic userGender;
@dynamic userNickName;
@dynamic avatarURL;
@dynamic departmentId;
@dynamic email;
@dynamic userRealName;
@dynamic userTel;
@dynamic userDomain;
@dynamic status;
@dynamic hasSignInfo, signInfo;

typedef struct UserInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t userId;
  uint32_t userGender;
  uint32_t departmentId;
  uint32_t status;
  NSString *userNickName;
  NSString *avatarURL;
  NSString *email;
  NSString *userRealName;
  NSString *userTel;
  NSString *userDomain;
  NSString *signInfo;
} UserInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = UserInfo_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserInfo__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "userGender",
        .dataTypeSpecific.clazz = Nil,
        .number = UserInfo_FieldNumber_UserGender,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UserInfo__storage_, userGender),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "userNickName",
        .dataTypeSpecific.clazz = Nil,
        .number = UserInfo_FieldNumber_UserNickName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UserInfo__storage_, userNickName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "avatarURL",
        .dataTypeSpecific.clazz = Nil,
        .number = UserInfo_FieldNumber_AvatarURL,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UserInfo__storage_, avatarURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "departmentId",
        .dataTypeSpecific.clazz = Nil,
        .number = UserInfo_FieldNumber_DepartmentId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(UserInfo__storage_, departmentId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "email",
        .dataTypeSpecific.clazz = Nil,
        .number = UserInfo_FieldNumber_Email,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(UserInfo__storage_, email),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userRealName",
        .dataTypeSpecific.clazz = Nil,
        .number = UserInfo_FieldNumber_UserRealName,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(UserInfo__storage_, userRealName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userTel",
        .dataTypeSpecific.clazz = Nil,
        .number = UserInfo_FieldNumber_UserTel,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(UserInfo__storage_, userTel),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userDomain",
        .dataTypeSpecific.clazz = Nil,
        .number = UserInfo_FieldNumber_UserDomain,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(UserInfo__storage_, userDomain),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "status",
        .dataTypeSpecific.clazz = Nil,
        .number = UserInfo_FieldNumber_Status,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(UserInfo__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "signInfo",
        .dataTypeSpecific.clazz = Nil,
        .number = UserInfo_FieldNumber_SignInfo,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(UserInfo__storage_, signInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserInfo class]
                                     rootClass:[ImBaseDefineRoot class]
                                          file:ImBaseDefineRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\004\006\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ContactSessionInfo

@implementation ContactSessionInfo

@dynamic sessionId;
@dynamic sessionType;
@dynamic sessionStatus;
@dynamic updatedTime;
@dynamic latestMsgId;
@dynamic latestMsgData;
@dynamic latestMsgType;
@dynamic latestMsgFromUserId;

typedef struct ContactSessionInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t sessionId;
  SessionType sessionType;
  SessionStatusType sessionStatus;
  uint32_t updatedTime;
  uint32_t latestMsgId;
  MsgType latestMsgType;
  uint32_t latestMsgFromUserId;
  NSData *latestMsgData;
} ContactSessionInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sessionId",
        .dataTypeSpecific.clazz = Nil,
        .number = ContactSessionInfo_FieldNumber_SessionId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ContactSessionInfo__storage_, sessionId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "sessionType",
        .dataTypeSpecific.enumDescFunc = SessionType_EnumDescriptor,
        .number = ContactSessionInfo_FieldNumber_SessionType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ContactSessionInfo__storage_, sessionType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "sessionStatus",
        .dataTypeSpecific.enumDescFunc = SessionStatusType_EnumDescriptor,
        .number = ContactSessionInfo_FieldNumber_SessionStatus,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ContactSessionInfo__storage_, sessionStatus),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "updatedTime",
        .dataTypeSpecific.clazz = Nil,
        .number = ContactSessionInfo_FieldNumber_UpdatedTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ContactSessionInfo__storage_, updatedTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "latestMsgId",
        .dataTypeSpecific.clazz = Nil,
        .number = ContactSessionInfo_FieldNumber_LatestMsgId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ContactSessionInfo__storage_, latestMsgId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "latestMsgData",
        .dataTypeSpecific.clazz = Nil,
        .number = ContactSessionInfo_FieldNumber_LatestMsgData,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ContactSessionInfo__storage_, latestMsgData),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "latestMsgType",
        .dataTypeSpecific.enumDescFunc = MsgType_EnumDescriptor,
        .number = ContactSessionInfo_FieldNumber_LatestMsgType,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ContactSessionInfo__storage_, latestMsgType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "latestMsgFromUserId",
        .dataTypeSpecific.clazz = Nil,
        .number = ContactSessionInfo_FieldNumber_LatestMsgFromUserId,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ContactSessionInfo__storage_, latestMsgFromUserId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ContactSessionInfo class]
                                     rootClass:[ImBaseDefineRoot class]
                                          file:ImBaseDefineRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ContactSessionInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ContactSessionInfo_SessionType_RawValue(ContactSessionInfo *message) {
  GPBDescriptor *descriptor = [ContactSessionInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ContactSessionInfo_FieldNumber_SessionType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetContactSessionInfo_SessionType_RawValue(ContactSessionInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [ContactSessionInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ContactSessionInfo_FieldNumber_SessionType];
  GPBSetMessageRawEnumField(message, field, value);
}

int32_t ContactSessionInfo_SessionStatus_RawValue(ContactSessionInfo *message) {
  GPBDescriptor *descriptor = [ContactSessionInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ContactSessionInfo_FieldNumber_SessionStatus];
  return GPBGetMessageRawEnumField(message, field);
}

void SetContactSessionInfo_SessionStatus_RawValue(ContactSessionInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [ContactSessionInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ContactSessionInfo_FieldNumber_SessionStatus];
  GPBSetMessageRawEnumField(message, field, value);
}

int32_t ContactSessionInfo_LatestMsgType_RawValue(ContactSessionInfo *message) {
  GPBDescriptor *descriptor = [ContactSessionInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ContactSessionInfo_FieldNumber_LatestMsgType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetContactSessionInfo_LatestMsgType_RawValue(ContactSessionInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [ContactSessionInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ContactSessionInfo_FieldNumber_LatestMsgType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - UserStat

@implementation UserStat

@dynamic userId;
@dynamic status;

typedef struct UserStat__storage_ {
  uint32_t _has_storage_[1];
  uint32_t userId;
  UserStatType status;
} UserStat__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = UserStat_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserStat__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = UserStatType_EnumDescriptor,
        .number = UserStat_FieldNumber_Status,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UserStat__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserStat class]
                                     rootClass:[ImBaseDefineRoot class]
                                          file:ImBaseDefineRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserStat__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t UserStat_Status_RawValue(UserStat *message) {
  GPBDescriptor *descriptor = [UserStat descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UserStat_FieldNumber_Status];
  return GPBGetMessageRawEnumField(message, field);
}

void SetUserStat_Status_RawValue(UserStat *message, int32_t value) {
  GPBDescriptor *descriptor = [UserStat descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UserStat_FieldNumber_Status];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - ServerUserStat

@implementation ServerUserStat

@dynamic userId;
@dynamic status;
@dynamic clientType;

typedef struct ServerUserStat__storage_ {
  uint32_t _has_storage_[1];
  uint32_t userId;
  UserStatType status;
  ClientType clientType;
} ServerUserStat__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = ServerUserStat_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ServerUserStat__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = UserStatType_EnumDescriptor,
        .number = ServerUserStat_FieldNumber_Status,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ServerUserStat__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "clientType",
        .dataTypeSpecific.enumDescFunc = ClientType_EnumDescriptor,
        .number = ServerUserStat_FieldNumber_ClientType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ServerUserStat__storage_, clientType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ServerUserStat class]
                                     rootClass:[ImBaseDefineRoot class]
                                          file:ImBaseDefineRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ServerUserStat__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ServerUserStat_Status_RawValue(ServerUserStat *message) {
  GPBDescriptor *descriptor = [ServerUserStat descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ServerUserStat_FieldNumber_Status];
  return GPBGetMessageRawEnumField(message, field);
}

void SetServerUserStat_Status_RawValue(ServerUserStat *message, int32_t value) {
  GPBDescriptor *descriptor = [ServerUserStat descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ServerUserStat_FieldNumber_Status];
  GPBSetMessageRawEnumField(message, field, value);
}

int32_t ServerUserStat_ClientType_RawValue(ServerUserStat *message) {
  GPBDescriptor *descriptor = [ServerUserStat descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ServerUserStat_FieldNumber_ClientType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetServerUserStat_ClientType_RawValue(ServerUserStat *message, int32_t value) {
  GPBDescriptor *descriptor = [ServerUserStat descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ServerUserStat_FieldNumber_ClientType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - UnreadInfo

@implementation UnreadInfo

@dynamic sessionId;
@dynamic sessionType;
@dynamic unreadCnt;
@dynamic latestMsgId;
@dynamic latestMsgData;
@dynamic latestMsgType;
@dynamic latestMsgFromUserId;

typedef struct UnreadInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t sessionId;
  SessionType sessionType;
  uint32_t unreadCnt;
  uint32_t latestMsgId;
  MsgType latestMsgType;
  uint32_t latestMsgFromUserId;
  NSData *latestMsgData;
} UnreadInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sessionId",
        .dataTypeSpecific.clazz = Nil,
        .number = UnreadInfo_FieldNumber_SessionId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UnreadInfo__storage_, sessionId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "sessionType",
        .dataTypeSpecific.enumDescFunc = SessionType_EnumDescriptor,
        .number = UnreadInfo_FieldNumber_SessionType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UnreadInfo__storage_, sessionType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "unreadCnt",
        .dataTypeSpecific.clazz = Nil,
        .number = UnreadInfo_FieldNumber_UnreadCnt,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UnreadInfo__storage_, unreadCnt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "latestMsgId",
        .dataTypeSpecific.clazz = Nil,
        .number = UnreadInfo_FieldNumber_LatestMsgId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UnreadInfo__storage_, latestMsgId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "latestMsgData",
        .dataTypeSpecific.clazz = Nil,
        .number = UnreadInfo_FieldNumber_LatestMsgData,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(UnreadInfo__storage_, latestMsgData),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "latestMsgType",
        .dataTypeSpecific.enumDescFunc = MsgType_EnumDescriptor,
        .number = UnreadInfo_FieldNumber_LatestMsgType,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(UnreadInfo__storage_, latestMsgType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "latestMsgFromUserId",
        .dataTypeSpecific.clazz = Nil,
        .number = UnreadInfo_FieldNumber_LatestMsgFromUserId,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(UnreadInfo__storage_, latestMsgFromUserId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UnreadInfo class]
                                     rootClass:[ImBaseDefineRoot class]
                                          file:ImBaseDefineRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UnreadInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t UnreadInfo_SessionType_RawValue(UnreadInfo *message) {
  GPBDescriptor *descriptor = [UnreadInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UnreadInfo_FieldNumber_SessionType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetUnreadInfo_SessionType_RawValue(UnreadInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [UnreadInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UnreadInfo_FieldNumber_SessionType];
  GPBSetMessageRawEnumField(message, field, value);
}

int32_t UnreadInfo_LatestMsgType_RawValue(UnreadInfo *message) {
  GPBDescriptor *descriptor = [UnreadInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UnreadInfo_FieldNumber_LatestMsgType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetUnreadInfo_LatestMsgType_RawValue(UnreadInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [UnreadInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UnreadInfo_FieldNumber_LatestMsgType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - MsgInfo

@implementation MsgInfo

@dynamic msgId;
@dynamic fromSessionId;
@dynamic createTime;
@dynamic msgType;
@dynamic msgData;

typedef struct MsgInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t msgId;
  uint32_t fromSessionId;
  uint32_t createTime;
  MsgType msgType;
  NSData *msgData;
} MsgInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msgId",
        .dataTypeSpecific.clazz = Nil,
        .number = MsgInfo_FieldNumber_MsgId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MsgInfo__storage_, msgId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "fromSessionId",
        .dataTypeSpecific.clazz = Nil,
        .number = MsgInfo_FieldNumber_FromSessionId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MsgInfo__storage_, fromSessionId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "createTime",
        .dataTypeSpecific.clazz = Nil,
        .number = MsgInfo_FieldNumber_CreateTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MsgInfo__storage_, createTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "msgType",
        .dataTypeSpecific.enumDescFunc = MsgType_EnumDescriptor,
        .number = MsgInfo_FieldNumber_MsgType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(MsgInfo__storage_, msgType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "msgData",
        .dataTypeSpecific.clazz = Nil,
        .number = MsgInfo_FieldNumber_MsgData,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(MsgInfo__storage_, msgData),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MsgInfo class]
                                     rootClass:[ImBaseDefineRoot class]
                                          file:ImBaseDefineRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MsgInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t MsgInfo_MsgType_RawValue(MsgInfo *message) {
  GPBDescriptor *descriptor = [MsgInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MsgInfo_FieldNumber_MsgType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetMsgInfo_MsgType_RawValue(MsgInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [MsgInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MsgInfo_FieldNumber_MsgType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - GroupVersionInfo

@implementation GroupVersionInfo

@dynamic groupId;
@dynamic version;

typedef struct GroupVersionInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t groupId;
  uint32_t version;
} GroupVersionInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.clazz = Nil,
        .number = GroupVersionInfo_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupVersionInfo__storage_, groupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "version",
        .dataTypeSpecific.clazz = Nil,
        .number = GroupVersionInfo_FieldNumber_Version,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupVersionInfo__storage_, version),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupVersionInfo class]
                                     rootClass:[ImBaseDefineRoot class]
                                          file:ImBaseDefineRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupVersionInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupInfo

@implementation GroupInfo

@dynamic groupId;
@dynamic version;
@dynamic groupName;
@dynamic groupAvatar;
@dynamic groupCreatorId;
@dynamic groupType;
@dynamic shieldStatus;
@dynamic groupMemberListArray, groupMemberListArray_Count;

typedef struct GroupInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t groupId;
  uint32_t version;
  uint32_t groupCreatorId;
  GroupType groupType;
  uint32_t shieldStatus;
  NSString *groupName;
  NSString *groupAvatar;
  GPBUInt32Array *groupMemberListArray;
} GroupInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.clazz = Nil,
        .number = GroupInfo_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupInfo__storage_, groupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "version",
        .dataTypeSpecific.clazz = Nil,
        .number = GroupInfo_FieldNumber_Version,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupInfo__storage_, version),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "groupName",
        .dataTypeSpecific.clazz = Nil,
        .number = GroupInfo_FieldNumber_GroupName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GroupInfo__storage_, groupName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "groupAvatar",
        .dataTypeSpecific.clazz = Nil,
        .number = GroupInfo_FieldNumber_GroupAvatar,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GroupInfo__storage_, groupAvatar),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "groupCreatorId",
        .dataTypeSpecific.clazz = Nil,
        .number = GroupInfo_FieldNumber_GroupCreatorId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GroupInfo__storage_, groupCreatorId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "groupType",
        .dataTypeSpecific.enumDescFunc = GroupType_EnumDescriptor,
        .number = GroupInfo_FieldNumber_GroupType,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(GroupInfo__storage_, groupType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "shieldStatus",
        .dataTypeSpecific.clazz = Nil,
        .number = GroupInfo_FieldNumber_ShieldStatus,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(GroupInfo__storage_, shieldStatus),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "groupMemberListArray",
        .dataTypeSpecific.clazz = Nil,
        .number = GroupInfo_FieldNumber_GroupMemberListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GroupInfo__storage_, groupMemberListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupInfo class]
                                     rootClass:[ImBaseDefineRoot class]
                                          file:ImBaseDefineRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t GroupInfo_GroupType_RawValue(GroupInfo *message) {
  GPBDescriptor *descriptor = [GroupInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GroupInfo_FieldNumber_GroupType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetGroupInfo_GroupType_RawValue(GroupInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [GroupInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GroupInfo_FieldNumber_GroupType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - UserTokenInfo

@implementation UserTokenInfo

@dynamic userId;
@dynamic userType;
@dynamic token;
@dynamic pushCount;
@dynamic pushType;

typedef struct UserTokenInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t userId;
  ClientType userType;
  uint32_t pushCount;
  uint32_t pushType;
  NSString *token;
} UserTokenInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = UserTokenInfo_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserTokenInfo__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "userType",
        .dataTypeSpecific.enumDescFunc = ClientType_EnumDescriptor,
        .number = UserTokenInfo_FieldNumber_UserType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UserTokenInfo__storage_, userType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "token",
        .dataTypeSpecific.clazz = Nil,
        .number = UserTokenInfo_FieldNumber_Token,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UserTokenInfo__storage_, token),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pushCount",
        .dataTypeSpecific.clazz = Nil,
        .number = UserTokenInfo_FieldNumber_PushCount,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UserTokenInfo__storage_, pushCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "pushType",
        .dataTypeSpecific.clazz = Nil,
        .number = UserTokenInfo_FieldNumber_PushType,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(UserTokenInfo__storage_, pushType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserTokenInfo class]
                                     rootClass:[ImBaseDefineRoot class]
                                          file:ImBaseDefineRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserTokenInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t UserTokenInfo_UserType_RawValue(UserTokenInfo *message) {
  GPBDescriptor *descriptor = [UserTokenInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UserTokenInfo_FieldNumber_UserType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetUserTokenInfo_UserType_RawValue(UserTokenInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [UserTokenInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UserTokenInfo_FieldNumber_UserType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - PushResult

@implementation PushResult

@dynamic userToken;
@dynamic resultCode;

typedef struct PushResult__storage_ {
  uint32_t _has_storage_[1];
  uint32_t resultCode;
  NSString *userToken;
} PushResult__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userToken",
        .dataTypeSpecific.clazz = Nil,
        .number = PushResult_FieldNumber_UserToken,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PushResult__storage_, userToken),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "resultCode",
        .dataTypeSpecific.clazz = Nil,
        .number = PushResult_FieldNumber_ResultCode,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PushResult__storage_, resultCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PushResult class]
                                     rootClass:[ImBaseDefineRoot class]
                                          file:ImBaseDefineRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PushResult__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ShieldStatus

@implementation ShieldStatus

@dynamic userId;
@dynamic groupId;
@dynamic shieldStatus;

typedef struct ShieldStatus__storage_ {
  uint32_t _has_storage_[1];
  uint32_t userId;
  uint32_t groupId;
  uint32_t shieldStatus;
} ShieldStatus__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = ShieldStatus_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ShieldStatus__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "groupId",
        .dataTypeSpecific.clazz = Nil,
        .number = ShieldStatus_FieldNumber_GroupId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ShieldStatus__storage_, groupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "shieldStatus",
        .dataTypeSpecific.clazz = Nil,
        .number = ShieldStatus_FieldNumber_ShieldStatus,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ShieldStatus__storage_, shieldStatus),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ShieldStatus class]
                                     rootClass:[ImBaseDefineRoot class]
                                          file:ImBaseDefineRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ShieldStatus__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - OfflineFileInfo

@implementation OfflineFileInfo

@dynamic fromUserId;
@dynamic taskId;
@dynamic fileName;
@dynamic fileSize;

typedef struct OfflineFileInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t fromUserId;
  uint32_t fileSize;
  NSString *taskId;
  NSString *fileName;
} OfflineFileInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fromUserId",
        .dataTypeSpecific.clazz = Nil,
        .number = OfflineFileInfo_FieldNumber_FromUserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(OfflineFileInfo__storage_, fromUserId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "taskId",
        .dataTypeSpecific.clazz = Nil,
        .number = OfflineFileInfo_FieldNumber_TaskId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(OfflineFileInfo__storage_, taskId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "fileName",
        .dataTypeSpecific.clazz = Nil,
        .number = OfflineFileInfo_FieldNumber_FileName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(OfflineFileInfo__storage_, fileName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "fileSize",
        .dataTypeSpecific.clazz = Nil,
        .number = OfflineFileInfo_FieldNumber_FileSize,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(OfflineFileInfo__storage_, fileSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OfflineFileInfo class]
                                     rootClass:[ImBaseDefineRoot class]
                                          file:ImBaseDefineRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OfflineFileInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AuthInfo

@implementation AuthInfo

@dynamic appKey;
@dynamic userId;
@dynamic allowdUserIds;
@dynamic allowdGroupIds;
@dynamic authInterfaces;
@dynamic authIps;

typedef struct AuthInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t userId;
  NSString *appKey;
  NSString *allowdUserIds;
  NSString *allowdGroupIds;
  NSString *authInterfaces;
  NSString *authIps;
} AuthInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "appKey",
        .dataTypeSpecific.clazz = Nil,
        .number = AuthInfo_FieldNumber_AppKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AuthInfo__storage_, appKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = AuthInfo_FieldNumber_UserId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AuthInfo__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "allowdUserIds",
        .dataTypeSpecific.clazz = Nil,
        .number = AuthInfo_FieldNumber_AllowdUserIds,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AuthInfo__storage_, allowdUserIds),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "allowdGroupIds",
        .dataTypeSpecific.clazz = Nil,
        .number = AuthInfo_FieldNumber_AllowdGroupIds,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AuthInfo__storage_, allowdGroupIds),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "authInterfaces",
        .dataTypeSpecific.clazz = Nil,
        .number = AuthInfo_FieldNumber_AuthInterfaces,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(AuthInfo__storage_, authInterfaces),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "authIps",
        .dataTypeSpecific.clazz = Nil,
        .number = AuthInfo_FieldNumber_AuthIps,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(AuthInfo__storage_, authIps),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AuthInfo class]
                                     rootClass:[ImBaseDefineRoot class]
                                          file:ImBaseDefineRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AuthInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DepartInfo

@implementation DepartInfo

@dynamic deptId;
@dynamic priority;
@dynamic deptName;
@dynamic parentDeptId;
@dynamic deptStatus;

typedef struct DepartInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t deptId;
  uint32_t priority;
  uint32_t parentDeptId;
  DepartmentStatusType deptStatus;
  NSString *deptName;
} DepartInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "deptId",
        .dataTypeSpecific.clazz = Nil,
        .number = DepartInfo_FieldNumber_DeptId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DepartInfo__storage_, deptId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "priority",
        .dataTypeSpecific.clazz = Nil,
        .number = DepartInfo_FieldNumber_Priority,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DepartInfo__storage_, priority),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "deptName",
        .dataTypeSpecific.clazz = Nil,
        .number = DepartInfo_FieldNumber_DeptName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DepartInfo__storage_, deptName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "parentDeptId",
        .dataTypeSpecific.clazz = Nil,
        .number = DepartInfo_FieldNumber_ParentDeptId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DepartInfo__storage_, parentDeptId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "deptStatus",
        .dataTypeSpecific.enumDescFunc = DepartmentStatusType_EnumDescriptor,
        .number = DepartInfo_FieldNumber_DeptStatus,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DepartInfo__storage_, deptStatus),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DepartInfo class]
                                     rootClass:[ImBaseDefineRoot class]
                                          file:ImBaseDefineRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DepartInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t DepartInfo_DeptStatus_RawValue(DepartInfo *message) {
  GPBDescriptor *descriptor = [DepartInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:DepartInfo_FieldNumber_DeptStatus];
  return GPBGetMessageRawEnumField(message, field);
}

void SetDepartInfo_DeptStatus_RawValue(DepartInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [DepartInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:DepartInfo_FieldNumber_DeptStatus];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - PushShieldStatus

@implementation PushShieldStatus

@dynamic userId;
@dynamic shieldStatus;

typedef struct PushShieldStatus__storage_ {
  uint32_t _has_storage_[1];
  uint32_t userId;
  uint32_t shieldStatus;
} PushShieldStatus__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = PushShieldStatus_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PushShieldStatus__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "shieldStatus",
        .dataTypeSpecific.clazz = Nil,
        .number = PushShieldStatus_FieldNumber_ShieldStatus,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PushShieldStatus__storage_, shieldStatus),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PushShieldStatus class]
                                     rootClass:[ImBaseDefineRoot class]
                                          file:ImBaseDefineRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PushShieldStatus__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
